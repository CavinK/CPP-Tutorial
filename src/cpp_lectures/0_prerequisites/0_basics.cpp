// Visual Studio: Compiler! <- 기계(on/off만 인식)가 고수준 언어를 인식할 수 있게 하는 거
// C++: 고수준 언어 <- 사람들이 좀 더 편하게 익히고 쓸 수 있는 언어

// #: 전처리기 <- 무언가를 포함시키는 기능
// #include: 헤더 파일을 여기에 포함시키는 기능이다. <- iostream: 입력, 출력을 위한 기능들을 제공
#include <iostream>

using namespace std; // 이 코드를 쓰면, 얘 밑으로는 기능들 앞에 std:: 안 붙여도 됨! <- 붙여도 상관은 없음!

// 코드는 위에서 아래, 오른쪽에서 왼쪽으로 읽어들임!
// 아래 코드들을 예로 들면, 먼저 endl을 읽어들이고, 그걸 왼쪽의 문자열에 붙이고, 그걸 통으로 cout에 넣어서 콘솔에 출력

// 실행 과정: 컴파일 -> 빌드 -> 실행
// 컴파일: 번역 작업이다. <- C++을 컴퓨터가 알아들을 수 있는 저수준 언어로 번역(binary code: 0, 1로만 구성)
// 빌드: Ctrl + Shift + B (이걸 이용해서 컴파일 및 빌드를 할 수 있다.)
// => 빌드가 완료되면 프로젝트에 Debug 폴더가 생겨나고, 그 안에 exe 파일이 생성됨!
// 실행: Ctrl + F5

// C++의 시작점은 main 함수이다.
// main 함수는 반드시 있어야 한다.
int main() // 프로그램의 시작점
{
	// std: iostream에 포함된 대부분의 C++ 표준 기능들은 std라는 namespace로 감싸져 있음!
	// C++는 기본적으로 이름이 같은 걸 허용하지 않음 <- 이 부분을 피해가기 위해 namespace 사용!

	// C++ 표준 기능의 대부분은 std 라는 namespace 안에 존재하고 있다.
	// 이름이 겹치는 것을 방지해주기 위해서 이다.
	// cout: 콘솔 창에 출력해주는 기능이다. 
	// 뒤에 있는 ""(큰따옴표) 안에 있는 문자들을 화면에 출력해준다.
	// 문자 여러 개를 사용할 때는 반드시 "" 안에 넣어주고 이런 걸 문자열이라고 한다.
	// endl: 개행 기능이다.
	std::cout << "Test Output" << std::endl; // iostream에 포함된 기능!
	std::cout << "ABCD" << std::endl;

	cout << "std 사용" << endl;

	/*
	변수: 변하는 수. 값이 바뀔 수 있다.
	용량의 최소 단위: bit <- 컴퓨터에서 1bit로 표현할 수 있는 건 0, 1 밖에 없음! => 2의 n승만큼 문자 표현 가능

	1byte = 8bit <- 1byte는 256(2^8)개의 문자를 표현하는 것이 가능!
	1kbyte = 1024byte
	1mbyte = 1024kbyte
	1gbyte = 1024mbyte
	1tbyte = 1024gbyte

	문자를 표현하는 방법: ASCII 코드 표를 가지고 있다. <- 문자를 숫자로 저장!
	false: 0
	true: 0이 아닌 모든 수
	unsigned: 부호가 없다.

	종류	|	용량	|	데이터	|	표현범위		|	unsigned	|
	char	|	1byte	|	문자	|	-128 ~ 127		|	0 ~ 255		|
	bool	|	1byte	|	참/거짓	|	true / false	|	true/false	|
	short	|	2byte	|	정수	| -32768 ~ 32767	|	0 ~ 65535	|
	int		|	4byte	|	정수	| 약 -22억 ~ 21억	|	0 ~ 약 43억	|
	float	|	4byte	|	실수	|
	double	|	8byte	|	실수	|

	short: 용량이 작은 정수
	float: 부동소수점(소수점 이하 자리가 바뀜)
	double: 소수점 이하 자리수를 더 많이 제공
	*/

	// = : 대입연산자이다. 오른쪽에 있는 값을 왼쪽으로 대입한다.
	int Number = 10; // 변수명 앞에 올 수 있는 특수문자는 _ 밖에 없음!
	Number = 20;

	cout << Number << endl;

	bool bTest = true;
	bTest = false;

	cout << bTest << endl;

	// 영문이나 숫자는 1byte를 차지한다.
	// 하지만 한글이나 한문 등의 문자들은 2byte를 차지하기 때문에 char 변수 하나에 저장하기가 힘들다.
	char cTest = 't';

	cout << cTest << endl;

	float fNumber = 3.14f; // 뒤에 f 안 붙여주면 double 타입의 실수가 됨

	cout << fNumber << endl;

	double dNumber = 123.4567;

	cout << dNumber << endl;

	/*
	사칙연산자: +, -, *, /, %(나머지 연산자)
	관계연산자: 값 대 값을 연산하여 참/거짓으로 결과를 반환한다.
	>, >=, <, <=, ==, !=

	논리연산자: 참/거짓 대 참/거짓 연산하여 참/거짓으로 결과를 반환한다.
	AND(&&), OR(||), NOT(!)
	A	B	AND	OR <- 나올 수 있는 경우의 수: 총 4가지
	0	0	0	0
	1	0	0	1
	0	1	0	1
	1	1	1	1

	A	NOT
	0	1
	1	0



	진수: 2진수, 8진수, 10진수, 16진수
	2진수: 0 ~ 1
	8진수: 0 ~ 7
	10진수: 0 ~ 9
	16진수: 0 ~ 15 <- 0 ~ 9: 일반적인 숫자 // 10 ~ 15: a ~ f

	진수들은 서로 다른 진수로 변환이 가능하다.
	87을 2진수, 16진수로 변환해보자.

	먼저 2진수로 변환한다. <- 계속 2로 나눈 다음에 역순으로 읽어들임!
	87 / 2 = 43 -- 1
	43 / 2 = 21 -- 1
	21 / 2 = 10 -- 1
	10 / 2 = 5 --- 0
	5 / 2 = 2 ---- 1
	2 / 2 = 1 ---- 0
	1 / 2 = 0 ---- 1
	가장 마지막에 나온 몫부터 역순으로 나머지 값들을 읽는다.
	1010111이 된다.

	16진수로 변환해보자.
	10진수를 바로 16진수로 변환하는 것보다 2진수로 변환한 후에 16진수로 변환하는 것이 쉽다.
	1010111을 오른쪽으로부터 4자리 씩 끊어서 계산한다.
	16진수 1자리는 2진수 4자리이다.
	0101	0111
	8421	8421

	2진수가 1인 부분의 값들을 더한다.
	16진수 57이 된다.



	비트 단위 논리연산자: 2진수 단위의 연산을 한다. 값 대 값을 연산하여 값으로 나온다.
	종류: AND(&), OR(|), NOT(~), XOR(^)
	A	B	XOR <- 둘이 같을 때는 false, 다를 때는 true
	0	0	0
	1	0	1
	0	1	1
	1	1	0

	ex.
	87 & 53 =
	87: 1010111
	53: 110101

	먼저 위처럼 2진수로 바꾼 후에 2진수 각 자리 별로 논리 연산을 실행한다.
	 1010111
	&0110101
	 0010101
	10101이 나온다.
	10진수로 변환하면 21이 나오게 된다.
	*/

	cout << "10 < 20 = " << (10 < 20) << endl;
	cout << "10 <= 20 = " << (10 <= 20) << endl;
	cout << "10 > 20 = " << (10 > 20) << endl;
	cout << "10 >= 20 = " << (10 >= 20) << endl;
	cout << "10 == 20 = " << (10 == 20) << endl;
	cout << "10 != 20 = " << (10 != 20) << endl;

	cout << "숫자를 입력하세요 :";
	cin >> Number; // cout과 화살표가 반대! <- cin에서 먼저 입력을 받아서 값을 변수에 넣어주는 거

	cout << "10 ~ 20 = " << (Number >= 10 && Number <= 20) << endl; // 연산자 우선순위: 관계연산자 > 논리연산자

	cout << "87 & 53 = " << (87 & 53) << endl;

	return 0;
}